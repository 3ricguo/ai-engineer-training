# 重排序两层过滤策略详解

## 问题背景

在RAG系统中，重排序后为什么要做两层过滤？这个设计的核心意义是什么？

## 两层过滤策略分析

### 第一层过滤：绝对分数阈值过滤

```python
# 第一层过滤：分数阈值
if filtered_documents := [doc for doc in source_documents if doc.metadata['score'] >= 0.28]:
    source_documents = filtered_documents
```

**目的：** 过滤掉明显不相关的文档

**原理：**
- 重排序模型给出的分数通常在0-1之间
- 0.28是经验阈值，低于此分数的文档被认为相关性太低
- 这是一个**硬性标准**，确保基本质量

**举例：**
```
重排序后的文档分数：
文档A: 0.85 ✓ (保留)
文档B: 0.72 ✓ (保留) 
文档C: 0.45 ✓ (保留)
文档D: 0.23 ✗ (过滤掉，相关性太低)
文档E: 0.15 ✗ (过滤掉，相关性太低)
```

### 第二层过滤：相对分数差异过滤

```python
# 第二层过滤：相对分数差异
saved_docs = [source_documents[0]]  # 保留最高分文档
for doc in source_documents[1:]:
    relative_difference = (saved_docs[0].metadata['score'] - doc.metadata['score']) / saved_docs[0].metadata['score']
    if relative_difference > 0.5:  # 相对差异超过50%
        break
    else:
        saved_docs.append(doc)
```

**目的：** 确保文档间的相关性一致性

**原理：**
- 计算当前文档与最高分文档的相对分数差异
- 如果差异超过50%，说明质量下降明显，停止添加
- 这是一个**相对标准**，确保文档质量的连续性

**举例：**
```
第一层过滤后的文档：
文档A: 0.85 (最高分，必保留)
文档B: 0.72 → 相对差异 = (0.85-0.72)/0.85 = 15.3% < 50% ✓ (保留)
文档C: 0.45 → 相对差异 = (0.85-0.45)/0.85 = 47.1% < 50% ✓ (保留)
文档D: 0.35 → 相对差异 = (0.85-0.35)/0.85 = 58.8% > 50% ✗ (停止，质量下降太多)
```

## 为什么需要两层过滤？

### 1. 解决不同场景的问题

**单独使用绝对阈值的问题：**
```python
# 场景1：所有文档分数都很高
文档分数：[0.95, 0.92, 0.89, 0.85, 0.82]
# 用0.28阈值 → 全部保留，可能包含太多文档

# 场景2：所有文档分数都较低
文档分数：[0.45, 0.42, 0.38, 0.35, 0.32]
# 用0.28阈值 → 全部保留，但质量参差不齐
```

**单独使用相对阈值的问题：**
```python
# 场景：最高分文档本身就不相关
文档分数：[0.25, 0.22, 0.20, 0.18, 0.15]
# 相对差异都很小 → 可能保留一堆不相关文档
```

### 2. 两层结合的优势

```python
# 理想场景：两层过滤协同工作
原始分数：[0.85, 0.72, 0.45, 0.23, 0.15, 0.35, 0.12]

# 第一层：绝对阈值过滤 (>= 0.28)
过滤后：[0.85, 0.72, 0.45, 0.35]

# 重新排序：[0.85, 0.72, 0.45, 0.35]

# 第二层：相对差异过滤
文档A: 0.85 ✓ (基准)
文档B: 0.72 → (0.85-0.72)/0.85 = 15.3% ✓
文档C: 0.45 → (0.85-0.45)/0.85 = 47.1% ✓  
文档D: 0.35 → (0.85-0.35)/0.85 = 58.8% ✗ (停止)

最终结果：[0.85, 0.72, 0.45] - 既保证了基本质量，又保证了一致性
```

## 实际效果对比

### 场景1：查询"Python编程入门"

**不使用两层过滤：**
```
返回10个文档，包含：
- Python基础教程 (高相关)
- Python高级特性 (中相关) 
- Java编程基础 (低相关)
- 数据库设计 (不相关)
- 网络协议 (不相关)
```

**使用两层过滤：**
```
返回3个文档，包含：
- Python基础教程 (高相关)
- Python语法详解 (高相关)
- Python实例教程 (中高相关)
```

### 场景2：查询"机器学习算法"

**重排序分数分布：**
```
文档1: 0.92 (机器学习基础)
文档2: 0.89 (深度学习算法) 
文档3: 0.85 (监督学习)
文档4: 0.45 (数据预处理) ← 质量断层
文档5: 0.42 (统计学基础)
```

**两层过滤效果：**
- 第一层：全部通过 (都>0.28)
- 第二层：在文档4处停止 (45%的相对差异接近50%阈值)
- 结果：返回前3个高质量文档，避免了质量断层

## 参数调优的考虑

### 绝对阈值 (0.28) 的选择

```python
# 经验数据分析
相关文档分数分布：0.4 - 1.0
不相关文档分数分布：0.0 - 0.4
重叠区间：0.25 - 0.4

# 选择0.28作为阈值：
# - 过滤掉大部分不相关文档
# - 保留大部分相关文档
# - 在精确率和召回率间取得平衡
```

### 相对阈值 (50%) 的选择

```python
# 人类感知的质量差异
相对差异 < 30%：用户几乎感觉不到质量差异
相对差异 30-50%：用户开始感觉到质量下降
相对差异 > 50%：用户明显感觉质量下降

# 选择50%：在质量一致性和文档数量间平衡
```

## 代码实现的细节考虑

### 1. 异常处理

```python
try:
    source_documents = await self.rerank.arerank_documents(condense_question, source_documents)
    # 两层过滤逻辑
except Exception as e:
    # 重排序失败时的降级策略
    time_record['rerank'] = 0.0
    debug_logger.error(f"rerank error: {traceback.format_exc()}")
```

### 2. 边界条件处理

```python
if len(source_documents) > 1:  # 只有多个文档时才需要过滤
    # 第一层过滤
    if filtered_documents := [...]:  # 使用海象操作符，优雅处理空列表
        source_documents = filtered_documents
```

### 3. 调试信息记录

```python
debug_logger.info(f"rerank step1 num: {len(source_documents)}")
debug_logger.info(f"rerank step1 scores: {[doc.metadata['score'] for doc in source_documents]}")
debug_logger.info(f"rerank step2 num: {len(source_documents)}")
debug_logger.info(f"rerank step3 num: {len(source_documents)}")
```

## 总结

两层过滤策略的核心意义：

1. **质量保证**：绝对阈值确保基本质量标准
2. **一致性保证**：相对阈值确保文档间质量的连续性  
3. **用户体验**：避免质量参差不齐的文档混合
4. **成本控制**：减少低质量文档的token消耗
5. **鲁棒性**：适应不同查询场景和分数分布

这种设计体现了RAG系统在**精确率**和**召回率**之间的精细平衡，是基于大量实践经验总结出的最佳实践。